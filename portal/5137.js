(self.webpackChunkportal=self.webpackChunkportal||[]).push([[5137],{5137:(fe,z,C)=>{C.d(z,{Ct:()=>$});var x=C(9671),w=C(1705),W=C(2411),b=C(1686),_=C(4125),p=C(2070);class F{}class O{}class D{}class U{constructor(o){this.type=o}}class S extends U{constructor(o,e=null){super(o),this.info=e}}class y extends U{constructor(o,e=null){super(o),this.info=e}}class k extends U{constructor(o,e,t=null){super(o),this.reason=e,this.params=t}}function M(h){const o=h.replace(/\-/g,"+").replace(/\_/g,"/");return decodeURIComponent(atob(o).split("").map(function(e){return"%"+("00"+e.charCodeAt(0).toString(16)).slice(-2)}).join(""))}function L(h){return btoa(h).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}class H{constructor(o){this.clientId="",this.redirectUri="",this.postLogoutRedirectUri="",this.redirectUriAsPostLogoutRedirectUriFallback=!0,this.loginUrl="",this.scope="openid profile",this.resource="",this.rngUrl="",this.oidc=!0,this.requestAccessToken=!0,this.options=null,this.issuer="",this.logoutUrl="",this.clearHashAfterLogin=!0,this.tokenEndpoint=null,this.revocationEndpoint=null,this.customTokenParameters=[],this.userinfoEndpoint=null,this.responseType="",this.showDebugInformation=!1,this.silentRefreshRedirectUri="",this.silentRefreshMessagePrefix="",this.silentRefreshShowIFrame=!1,this.siletRefreshTimeout=2e4,this.silentRefreshTimeout=2e4,this.dummyClientSecret="",this.requireHttps="remoteOnly",this.strictDiscoveryDocumentValidation=!0,this.jwks=null,this.customQueryParams=null,this.silentRefreshIFrameName="angular-oauth-oidc-silent-refresh-iframe",this.timeoutFactor=.75,this.sessionChecksEnabled=!1,this.sessionCheckIntervall=3e3,this.sessionCheckIFrameUrl=null,this.sessionCheckIFrameName="angular-oauth-oidc-check-session-iframe",this.disableAtHashCheck=!1,this.skipSubjectCheck=!1,this.useIdTokenHintForSilentRefresh=!1,this.skipIssuerCheck=!1,this.nonceStateSeparator=";",this.useHttpBasicAuth=!1,this.decreaseExpirationBySec=0,this.waitForTokenInMsec=0,this.disablePKCE=!1,this.preserveRequestedRoute=!1,this.disableIdTokenTimer=!1,this.checkOrigin=!1,this.openUri=e=>{location.href=e},o&&Object.assign(this,o)}}class A{encodeKey(o){return encodeURIComponent(o)}encodeValue(o){return encodeURIComponent(o)}decodeKey(o){return decodeURIComponent(o)}decodeValue(o){return decodeURIComponent(o)}}class N{}let B=(()=>{class h{getHashFragmentParams(e){let t=e||window.location.hash;if(t=decodeURIComponent(t),0!==t.indexOf("#"))return{};const i=t.indexOf("?");return t=t.substr(i>-1?i+1:1),this.parseQueryString(t)}parseQueryString(e){const t={};let i,s,n,r,c,l,f;if(null===e)return t;i=e.split("&");for(let a=0;a<i.length;a++)s=i[a],n=s.indexOf("="),-1===n?(r=s,c=null):(r=s.substr(0,n),c=s.substr(n+1)),l=decodeURIComponent(r),f=decodeURIComponent(c),"/"===l.substr(0,1)&&(l=l.substr(1)),t[l]=f;return t}}return h.\u0275fac=function(e){return new(e||h)},h.\u0275prov=w.\u0275\u0275defineInjectable({token:h,factory:h.\u0275fac}),h})();new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),new Uint8Array(32);class J{}let $=(()=>{class h extends H{constructor(e,t,i,s,n,r,c,l,f,a){super(),this.ngZone=e,this.http=t,this.config=n,this.urlHelper=r,this.logger=c,this.crypto=l,this.dateTimeService=a,this.discoveryDocumentLoaded=!1,this.state="",this.eventsSubject=new _.Subject,this.discoveryDocumentLoadedSubject=new _.Subject,this.grantTypesSupported=[],this.inImplicitFlow=!1,this.saveNoncesInLocalStorage=!1,this.debug("angular-oauth2-oidc v10"),this.document=f,n||(n={}),this.discoveryDocumentLoaded$=this.discoveryDocumentLoadedSubject.asObservable(),this.events=this.eventsSubject.asObservable(),s&&(this.tokenValidationHandler=s),n&&this.configure(n);try{i?this.setStorage(i):typeof sessionStorage<"u"&&this.setStorage(sessionStorage)}catch(d){console.error("No OAuthStorage provided and cannot access default (sessionStorage).Consider providing a custom OAuthStorage implementation in your module.",d)}if(this.checkLocalStorageAccessable()){const d=window?.navigator?.userAgent;(d?.includes("MSIE ")||d?.includes("Trident"))&&(this.saveNoncesInLocalStorage=!0)}this.setupRefreshTimer()}checkLocalStorageAccessable(){if(typeof window>"u")return!1;const e="test";try{return!(typeof window.localStorage>"u"||(localStorage.setItem(e,e),localStorage.removeItem(e),0))}catch{return!1}}configure(e){Object.assign(this,new H,e),this.config=Object.assign({},new H,e),this.sessionChecksEnabled&&this.setupSessionCheck(),this.configChanged()}configChanged(){this.setupRefreshTimer()}restartSessionChecksIfStillLoggedIn(){this.hasValidIdToken()&&this.initSessionCheck()}restartRefreshTimerIfStillLoggedIn(){this.setupExpirationTimers()}setupSessionCheck(){this.events.pipe((0,p.filter)(e=>"token_received"===e.type)).subscribe(e=>{this.initSessionCheck()})}setupAutomaticSilentRefresh(e={},t,i=!0){let s=!0;this.clearAutomaticRefreshTimer(),this.automaticRefreshSubscription=this.events.pipe((0,p.tap)(n=>{"token_received"===n.type?s=!0:"logout"===n.type&&(s=!1)}),(0,p.filter)(n=>"token_expires"===n.type&&(null==t||"any"===t||n.info===t)),(0,p.debounceTime)(1e3)).subscribe(n=>{s&&this.refreshInternal(e,i).catch(r=>{this.debug("Automatic silent refresh did not work")})}),this.restartRefreshTimerIfStillLoggedIn()}refreshInternal(e,t){return this.useSilentRefresh||"code"!==this.responseType?this.silentRefresh(e,t):this.refreshToken()}loadDiscoveryDocumentAndTryLogin(e=null){return this.loadDiscoveryDocument().then(t=>this.tryLogin(e))}loadDiscoveryDocumentAndLogin(e=null){return this.loadDiscoveryDocumentAndTryLogin(e=e||{}).then(t=>!(!this.hasValidIdToken()||!this.hasValidAccessToken())||(this.initLoginFlow("string"==typeof e.state?e.state:""),!1))}debug(...e){this.showDebugInformation&&this.logger.debug.apply(this.logger,e)}validateUrlFromDiscoveryDocument(e){const t=[],i=this.validateUrlForHttps(e),s=this.validateUrlAgainstIssuer(e);return i||t.push("https for all urls required. Also for urls received by discovery."),s||t.push("Every url in discovery document has to start with the issuer url.Also see property strictDiscoveryDocumentValidation."),t}validateUrlForHttps(e){if(!e)return!0;const t=e.toLowerCase();return!(!1!==this.requireHttps&&(!t.match(/^http:\/\/localhost($|[:\/])/)&&!t.match(/^http:\/\/localhost($|[:\/])/)||"remoteOnly"!==this.requireHttps))||t.startsWith("https://")}assertUrlNotNullAndCorrectProtocol(e,t){if(!e)throw new Error(`'${t}' should not be null`);if(!this.validateUrlForHttps(e))throw new Error(`'${t}' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).`)}validateUrlAgainstIssuer(e){return!this.strictDiscoveryDocumentValidation||!e||e.toLowerCase().startsWith(this.issuer.toLowerCase())}setupRefreshTimer(){typeof window>"u"?this.debug("timer not supported on this plattform"):((this.hasValidIdToken()||this.hasValidAccessToken())&&(this.clearAccessTokenTimer(),this.clearIdTokenTimer(),this.setupExpirationTimers()),this.tokenReceivedSubscription&&this.tokenReceivedSubscription.unsubscribe(),this.tokenReceivedSubscription=this.events.pipe((0,p.filter)(e=>"token_received"===e.type)).subscribe(e=>{this.clearAccessTokenTimer(),this.clearIdTokenTimer(),this.setupExpirationTimers()}))}setupExpirationTimers(){this.hasValidAccessToken()&&this.setupAccessTokenTimer(),!this.disableIdTokenTimer&&this.hasValidIdToken()&&this.setupIdTokenTimer()}setupAccessTokenTimer(){const e=this.getAccessTokenExpiration(),t=this.getAccessTokenStoredAt(),i=this.calcTimeout(t,e);this.ngZone.runOutsideAngular(()=>{this.accessTokenTimeoutSubscription=(0,_.of)(new y("token_expires","access_token")).pipe((0,p.delay)(i)).subscribe(s=>{this.ngZone.run(()=>{this.eventsSubject.next(s)})})})}setupIdTokenTimer(){const e=this.getIdTokenExpiration(),t=this.getIdTokenStoredAt(),i=this.calcTimeout(t,e);this.ngZone.runOutsideAngular(()=>{this.idTokenTimeoutSubscription=(0,_.of)(new y("token_expires","id_token")).pipe((0,p.delay)(i)).subscribe(s=>{this.ngZone.run(()=>{this.eventsSubject.next(s)})})})}stopAutomaticRefresh(){this.clearAccessTokenTimer(),this.clearIdTokenTimer(),this.clearAutomaticRefreshTimer()}clearAccessTokenTimer(){this.accessTokenTimeoutSubscription&&this.accessTokenTimeoutSubscription.unsubscribe()}clearIdTokenTimer(){this.idTokenTimeoutSubscription&&this.idTokenTimeoutSubscription.unsubscribe()}clearAutomaticRefreshTimer(){this.automaticRefreshSubscription&&this.automaticRefreshSubscription.unsubscribe()}calcTimeout(e,t){const i=this.dateTimeService.now(),n=Math.max(0,(t-e)*this.timeoutFactor-(i-e)),r=2147483647;return n>r?r:n}setStorage(e){this._storage=e,this.configChanged()}loadDiscoveryDocument(e=null){return new Promise((t,i)=>{e||((e=this.issuer||"").endsWith("/")||(e+="/"),e+=".well-known/openid-configuration"),this.validateUrlForHttps(e)?this.http.get(e).subscribe(s=>{if(!this.validateDiscoveryDocument(s))return this.eventsSubject.next(new k("discovery_document_validation_error",null)),void i("discovery_document_validation_error");this.loginUrl=s.authorization_endpoint,this.logoutUrl=s.end_session_endpoint||this.logoutUrl,this.grantTypesSupported=s.grant_types_supported,this.issuer=s.issuer,this.tokenEndpoint=s.token_endpoint,this.userinfoEndpoint=s.userinfo_endpoint||this.userinfoEndpoint,this.jwksUri=s.jwks_uri,this.sessionCheckIFrameUrl=s.check_session_iframe||this.sessionCheckIFrameUrl,this.discoveryDocumentLoaded=!0,this.discoveryDocumentLoadedSubject.next(s),this.revocationEndpoint=s.revocation_endpoint||this.revocationEndpoint,this.sessionChecksEnabled&&this.restartSessionChecksIfStillLoggedIn(),this.loadJwks().then(n=>{const c=new S("discovery_document_loaded",{discoveryDocument:s,jwks:n});this.eventsSubject.next(c),t(c)}).catch(n=>{this.eventsSubject.next(new k("discovery_document_load_error",n)),i(n)})},s=>{this.logger.error("error loading discovery document",s),this.eventsSubject.next(new k("discovery_document_load_error",s)),i(s)}):i("issuer  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).")})}loadJwks(){return new Promise((e,t)=>{this.jwksUri?this.http.get(this.jwksUri).subscribe(i=>{this.jwks=i,e(i)},i=>{this.logger.error("error loading jwks",i),this.eventsSubject.next(new k("jwks_load_error",i)),t(i)}):e(null)})}validateDiscoveryDocument(e){let t;return this.skipIssuerCheck||e.issuer===this.issuer?(t=this.validateUrlFromDiscoveryDocument(e.authorization_endpoint),t.length>0?(this.logger.error("error validating authorization_endpoint in discovery document",t),!1):(t=this.validateUrlFromDiscoveryDocument(e.end_session_endpoint),t.length>0?(this.logger.error("error validating end_session_endpoint in discovery document",t),!1):(t=this.validateUrlFromDiscoveryDocument(e.token_endpoint),t.length>0&&this.logger.error("error validating token_endpoint in discovery document",t),t=this.validateUrlFromDiscoveryDocument(e.revocation_endpoint),t.length>0&&this.logger.error("error validating revocation_endpoint in discovery document",t),t=this.validateUrlFromDiscoveryDocument(e.userinfo_endpoint),t.length>0?(this.logger.error("error validating userinfo_endpoint in discovery document",t),!1):(t=this.validateUrlFromDiscoveryDocument(e.jwks_uri),t.length>0?(this.logger.error("error validating jwks_uri in discovery document",t),!1):(this.sessionChecksEnabled&&!e.check_session_iframe&&this.logger.warn("sessionChecksEnabled is activated but discovery document does not contain a check_session_iframe field"),!0))))):(this.logger.error("invalid issuer in discovery document","expected: "+this.issuer,"current: "+e.issuer),!1)}fetchTokenUsingPasswordFlowAndLoadUserProfile(e,t,i=new b.HttpHeaders){return this.fetchTokenUsingPasswordFlow(e,t,i).then(()=>this.loadUserProfile())}loadUserProfile(){if(!this.hasValidAccessToken())throw new Error("Can not load User Profile without access_token");if(!this.validateUrlForHttps(this.userinfoEndpoint))throw new Error("userinfoEndpoint must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).");return new Promise((e,t)=>{const i=(new b.HttpHeaders).set("Authorization","Bearer "+this.getAccessToken());this.http.get(this.userinfoEndpoint,{headers:i,observe:"response",responseType:"text"}).subscribe(s=>{if(this.debug("userinfo received",JSON.stringify(s)),s.headers.get("content-type").startsWith("application/json")){let n=JSON.parse(s.body);const r=this.getIdentityClaims()||{};if(!this.skipSubjectCheck&&this.oidc&&(!r.sub||n.sub!==r.sub))return void t("if property oidc is true, the received user-id (sub) has to be the user-id of the user that has logged in with oidc.\nif you are not using oidc but just oauth2 password flow set oidc to false");n=Object.assign({},r,n),this._storage.setItem("id_token_claims_obj",JSON.stringify(n)),this.eventsSubject.next(new S("user_profile_loaded")),e({info:n})}else this.debug("userinfo is not JSON, treating it as JWE/JWS"),this.eventsSubject.next(new S("user_profile_loaded")),e(JSON.parse(s.body))},s=>{this.logger.error("error loading user info",s),this.eventsSubject.next(new k("user_profile_load_error",s)),t(s)})})}fetchTokenUsingPasswordFlow(e,t,i=new b.HttpHeaders){return this.fetchTokenUsingGrant("password",{username:e,password:t},i)}fetchTokenUsingGrant(e,t,i=new b.HttpHeaders){this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint,"tokenEndpoint");let s=new b.HttpParams({encoder:new A}).set("grant_type",e).set("scope",this.scope);if(this.useHttpBasicAuth){const n=btoa(`${this.clientId}:${this.dummyClientSecret}`);i=i.set("Authorization","Basic "+n)}if(this.useHttpBasicAuth||(s=s.set("client_id",this.clientId)),!this.useHttpBasicAuth&&this.dummyClientSecret&&(s=s.set("client_secret",this.dummyClientSecret)),this.customQueryParams)for(const n of Object.getOwnPropertyNames(this.customQueryParams))s=s.set(n,this.customQueryParams[n]);for(const n of Object.keys(t))s=s.set(n,t[n]);return i=i.set("Content-Type","application/x-www-form-urlencoded"),new Promise((n,r)=>{this.http.post(this.tokenEndpoint,s,{headers:i}).subscribe(c=>{this.debug("tokenResponse",c),this.storeAccessTokenResponse(c.access_token,c.refresh_token,c.expires_in||this.fallbackAccessTokenExpirationTimeInSec,c.scope,this.extractRecognizedCustomParameters(c)),this.oidc&&c.id_token&&this.processIdToken(c.id_token,c.access_token).then(l=>{this.storeIdToken(l),n(c)}),this.eventsSubject.next(new S("token_received")),n(c)},c=>{this.logger.error("Error performing ${grantType} flow",c),this.eventsSubject.next(new k("token_error",c)),r(c)})})}refreshToken(){return this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint,"tokenEndpoint"),new Promise((e,t)=>{let i=new b.HttpParams({encoder:new A}).set("grant_type","refresh_token").set("scope",this.scope).set("refresh_token",this._storage.getItem("refresh_token")),s=(new b.HttpHeaders).set("Content-Type","application/x-www-form-urlencoded");if(this.useHttpBasicAuth){const n=btoa(`${this.clientId}:${this.dummyClientSecret}`);s=s.set("Authorization","Basic "+n)}if(this.useHttpBasicAuth||(i=i.set("client_id",this.clientId)),!this.useHttpBasicAuth&&this.dummyClientSecret&&(i=i.set("client_secret",this.dummyClientSecret)),this.customQueryParams)for(const n of Object.getOwnPropertyNames(this.customQueryParams))i=i.set(n,this.customQueryParams[n]);this.http.post(this.tokenEndpoint,i,{headers:s}).pipe((0,p.switchMap)(n=>this.oidc&&n.id_token?(0,_.from)(this.processIdToken(n.id_token,n.access_token,!0)).pipe((0,p.tap)(r=>this.storeIdToken(r)),(0,p.map)(r=>n)):(0,_.of)(n))).subscribe(n=>{this.debug("refresh tokenResponse",n),this.storeAccessTokenResponse(n.access_token,n.refresh_token,n.expires_in||this.fallbackAccessTokenExpirationTimeInSec,n.scope,this.extractRecognizedCustomParameters(n)),this.eventsSubject.next(new S("token_received")),this.eventsSubject.next(new S("token_refreshed")),e(n)},n=>{this.logger.error("Error refreshing token",n),this.eventsSubject.next(new k("token_refresh_error",n)),t(n)})})}removeSilentRefreshEventListener(){this.silentRefreshPostMessageEventListener&&(window.removeEventListener("message",this.silentRefreshPostMessageEventListener),this.silentRefreshPostMessageEventListener=null)}setupSilentRefreshEventListener(){this.removeSilentRefreshEventListener(),this.silentRefreshPostMessageEventListener=e=>{const t=this.processMessageEventMessage(e);this.checkOrigin&&e.origin!==location.origin&&console.error("wrong origin requested silent refresh!"),this.tryLogin({customHashFragment:t,preventClearHashAfterLogin:!0,customRedirectUri:this.silentRefreshRedirectUri||this.redirectUri}).catch(i=>this.debug("tryLogin during silent refresh failed",i))},window.addEventListener("message",this.silentRefreshPostMessageEventListener)}silentRefresh(e={},t=!0){const i=this.getIdentityClaims()||{};if(this.useIdTokenHintForSilentRefresh&&this.hasValidIdToken()&&(e.id_token_hint=this.getIdToken()),!this.validateUrlForHttps(this.loginUrl))throw new Error("loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).");if(typeof this.document>"u")throw new Error("silent refresh is not supported on this platform");const s=this.document.getElementById(this.silentRefreshIFrameName);s&&this.document.body.removeChild(s),this.silentRefreshSubject=i.sub;const n=this.document.createElement("iframe");n.id=this.silentRefreshIFrameName,this.setupSilentRefreshEventListener(),this.createLoginUrl(null,null,this.silentRefreshRedirectUri||this.redirectUri,t,e).then(a=>{n.setAttribute("src",a),this.silentRefreshShowIFrame||(n.style.display="none"),this.document.body.appendChild(n)});const c=this.events.pipe((0,p.filter)(a=>a instanceof k),(0,p.first)()),l=this.events.pipe((0,p.filter)(a=>"token_received"===a.type),(0,p.first)()),f=(0,_.of)(new k("silent_refresh_timeout",null)).pipe((0,p.delay)(this.silentRefreshTimeout));return(0,_.race)([c,l,f]).pipe((0,p.map)(a=>{if(a instanceof k)throw"silent_refresh_timeout"===a.type||(a=new k("silent_refresh_error",a)),this.eventsSubject.next(a),a;return"token_received"===a.type&&(a=new S("silently_refreshed"),this.eventsSubject.next(a)),a})).toPromise()}initImplicitFlowInPopup(e){return this.initLoginFlowInPopup(e)}initLoginFlowInPopup(e){return e=e||{},this.createLoginUrl(null,null,this.silentRefreshRedirectUri,!1,{display:"popup"}).then(t=>new Promise((i,s)=>{let c,r=null;e.windowRef?e.windowRef&&!e.windowRef.closed&&(r=e.windowRef,r.location.href=t):r=window.open(t,"ngx-oauth2-oidc-login",this.calculatePopupFeatures(e));const l=g=>{this.tryLogin({customHashFragment:g,preventClearHashAfterLogin:!0,customRedirectUri:this.silentRefreshRedirectUri}).then(()=>{a(),i(!0)},v=>{a(),s(v)})};r?c=window.setInterval(()=>{(!r||r.closed)&&(a(),s(new k("popup_closed",{})))},500):s(new k("popup_blocked",{}));const a=()=>{window.clearInterval(c),window.removeEventListener("storage",u),window.removeEventListener("message",d),null!==r&&r.close(),r=null},d=g=>{const v=this.processMessageEventMessage(g);v&&null!==v?(window.removeEventListener("storage",u),l(v)):console.log("false event firing")},u=g=>{"auth_hash"===g.key&&(window.removeEventListener("message",d),l(g.newValue))};window.addEventListener("message",d),window.addEventListener("storage",u)}))}calculatePopupFeatures(e){const t=e.height||470,i=e.width||500,s=window.screenLeft+(window.outerWidth-i)/2;return`location=no,toolbar=no,width=${i},height=${t},top=${window.screenTop+(window.outerHeight-t)/2},left=${s}`}processMessageEventMessage(e){let t="#";if(this.silentRefreshMessagePrefix&&(t+=this.silentRefreshMessagePrefix),!e||!e.data||"string"!=typeof e.data)return;const i=e.data;return i.startsWith(t)?"#"+i.substr(t.length):void 0}canPerformSessionCheck(){return!(!this.sessionChecksEnabled||(this.sessionCheckIFrameUrl?this.getSessionState()?typeof this.document>"u":(console.warn("sessionChecksEnabled is activated but there is no session_state"),1):(console.warn("sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl"),1)))}setupSessionCheckEventListener(){this.removeSessionCheckEventListener(),this.sessionCheckEventListener=e=>{const t=e.origin.toLowerCase(),i=this.issuer.toLowerCase();if(this.debug("sessionCheckEventListener"),i.startsWith(t)){switch(e.data){case"unchanged":this.ngZone.run(()=>{this.handleSessionUnchanged()});break;case"changed":this.ngZone.run(()=>{this.handleSessionChange()});break;case"error":this.ngZone.run(()=>{this.handleSessionError()})}this.debug("got info from session check inframe",e)}else this.debug("sessionCheckEventListener","wrong origin",t,"expected",i,"event",e)},this.ngZone.runOutsideAngular(()=>{window.addEventListener("message",this.sessionCheckEventListener)})}handleSessionUnchanged(){this.debug("session check","session unchanged"),this.eventsSubject.next(new y("session_unchanged"))}handleSessionChange(){this.eventsSubject.next(new y("session_changed")),this.stopSessionCheckTimer(),this.useSilentRefresh||"code"!==this.responseType?this.silentRefreshRedirectUri?(this.silentRefresh().catch(e=>this.debug("silent refresh failed after session changed")),this.waitForSilentRefreshAfterSessionChange()):(this.eventsSubject.next(new y("session_terminated")),this.logOut(!0)):this.refreshToken().then(e=>{this.debug("token refresh after session change worked")}).catch(e=>{this.debug("token refresh did not work after session changed"),this.eventsSubject.next(new y("session_terminated")),this.logOut(!0)})}waitForSilentRefreshAfterSessionChange(){this.events.pipe((0,p.filter)(e=>"silently_refreshed"===e.type||"silent_refresh_timeout"===e.type||"silent_refresh_error"===e.type),(0,p.first)()).subscribe(e=>{"silently_refreshed"!==e.type&&(this.debug("silent refresh did not work after session changed"),this.eventsSubject.next(new y("session_terminated")),this.logOut(!0))})}handleSessionError(){this.stopSessionCheckTimer(),this.eventsSubject.next(new y("session_error"))}removeSessionCheckEventListener(){this.sessionCheckEventListener&&(window.removeEventListener("message",this.sessionCheckEventListener),this.sessionCheckEventListener=null)}initSessionCheck(){if(!this.canPerformSessionCheck())return;const e=this.document.getElementById(this.sessionCheckIFrameName);e&&this.document.body.removeChild(e);const t=this.document.createElement("iframe");t.id=this.sessionCheckIFrameName,this.setupSessionCheckEventListener(),t.setAttribute("src",this.sessionCheckIFrameUrl),t.style.display="none",this.document.body.appendChild(t),this.startSessionCheckTimer()}startSessionCheckTimer(){this.stopSessionCheckTimer(),this.ngZone.runOutsideAngular(()=>{this.sessionCheckTimer=setInterval(this.checkSession.bind(this),this.sessionCheckIntervall)})}stopSessionCheckTimer(){this.sessionCheckTimer&&(clearInterval(this.sessionCheckTimer),this.sessionCheckTimer=null)}checkSession(){const e=this.document.getElementById(this.sessionCheckIFrameName);e||this.logger.warn("checkSession did not find iframe",this.sessionCheckIFrameName);const t=this.getSessionState();t||this.stopSessionCheckTimer(),e.contentWindow.postMessage(this.clientId+" "+t,this.issuer)}createLoginUrl(e="",t="",i="",s=!1,n={}){var r=this;return(0,x.Z)(function*(){const c=r;let l;l=i||r.redirectUri;const f=yield r.createAndSaveNonce();if(e=e?f+r.config.nonceStateSeparator+encodeURIComponent(e):f,!r.requestAccessToken&&!r.oidc)throw new Error("Either requestAccessToken or oidc or both must be true");r.responseType=r.config.responseType?r.config.responseType:r.oidc&&r.requestAccessToken?"id_token token":r.oidc&&!r.requestAccessToken?"id_token":"token";const a=c.loginUrl.indexOf("?")>-1?"&":"?";let d=c.scope;r.oidc&&!d.match(/(^|\s)openid($|\s)/)&&(d="openid "+d);let u=c.loginUrl+a+"response_type="+encodeURIComponent(c.responseType)+"&client_id="+encodeURIComponent(c.clientId)+"&state="+encodeURIComponent(e)+"&redirect_uri="+encodeURIComponent(l)+"&scope="+encodeURIComponent(d);if(r.responseType.includes("code")&&!r.disablePKCE){const[g,v]=yield r.createChallangeVerifierPairForPKCE();r.saveNoncesInLocalStorage&&typeof window.localStorage<"u"?localStorage.setItem("PKCE_verifier",v):r._storage.setItem("PKCE_verifier",v),u+="&code_challenge="+g,u+="&code_challenge_method=S256"}t&&(u+="&login_hint="+encodeURIComponent(t)),c.resource&&(u+="&resource="+encodeURIComponent(c.resource)),c.oidc&&(u+="&nonce="+encodeURIComponent(f)),s&&(u+="&prompt=none");for(const g of Object.keys(n))u+="&"+encodeURIComponent(g)+"="+encodeURIComponent(n[g]);if(r.customQueryParams)for(const g of Object.getOwnPropertyNames(r.customQueryParams))u+="&"+g+"="+encodeURIComponent(r.customQueryParams[g]);return u})()}initImplicitFlowInternal(e="",t=""){if(this.inImplicitFlow)return;if(this.inImplicitFlow=!0,!this.validateUrlForHttps(this.loginUrl))throw new Error("loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).");let i={},s=null;"string"==typeof t?s=t:"object"==typeof t&&(i=t),this.createLoginUrl(e,s,null,!1,i).then(this.config.openUri).catch(n=>{console.error("Error in initImplicitFlow",n),this.inImplicitFlow=!1})}initImplicitFlow(e="",t=""){""!==this.loginUrl?this.initImplicitFlowInternal(e,t):this.events.pipe((0,p.filter)(i=>"discovery_document_loaded"===i.type)).subscribe(i=>this.initImplicitFlowInternal(e,t))}resetImplicitFlow(){this.inImplicitFlow=!1}callOnTokenReceivedIfExists(e){const t=this;if(e.onTokenReceived){const i={idClaims:t.getIdentityClaims(),idToken:t.getIdToken(),accessToken:t.getAccessToken(),state:t.state};e.onTokenReceived(i)}}storeAccessTokenResponse(e,t,i,s,n){if(this._storage.setItem("access_token",e),s&&!Array.isArray(s)?this._storage.setItem("granted_scopes",JSON.stringify(s.split(" "))):s&&Array.isArray(s)&&this._storage.setItem("granted_scopes",JSON.stringify(s)),this._storage.setItem("access_token_stored_at",""+this.dateTimeService.now()),i){const r=1e3*i,l=this.dateTimeService.new().getTime()+r;this._storage.setItem("expires_at",""+l)}t&&this._storage.setItem("refresh_token",t),n&&n.forEach((r,c)=>{this._storage.setItem(c,r)})}tryLogin(e=null){return"code"===this.config.responseType?this.tryLoginCodeFlow(e).then(t=>!0):this.tryLoginImplicitFlow(e)}parseQueryString(e){return e&&0!==e.length?("?"===e.charAt(0)&&(e=e.substr(1)),this.urlHelper.parseQueryString(e)):{}}tryLoginCodeFlow(e=null){var t=this;return(0,x.Z)(function*(){const i=(e=e||{}).customHashFragment?e.customHashFragment.substring(1):window.location.search,s=t.getCodePartsFromUrl(i),n=s.code,r=s.state,c=s.session_state;if(!e.preventClearHashAfterLogin){const a=location.origin+location.pathname+location.search.replace(/code=[^&\$]*/,"").replace(/scope=[^&\$]*/,"").replace(/state=[^&\$]*/,"").replace(/session_state=[^&\$]*/,"").replace(/^\?&/,"?").replace(/&$/,"").replace(/^\?$/,"").replace(/&+/g,"&").replace(/\?&/,"?").replace(/\?$/,"")+location.hash;history.replaceState(null,window.name,a)}let[l,f]=t.parseState(r);if(t.state=f,s.error){t.debug("error trying to login"),t.handleLoginError(e,s);const a=new k("code_error",{},s);return t.eventsSubject.next(a),Promise.reject(a)}if(!e.disableNonceCheck){if(!l)return t.saveRequestedRoute(),Promise.resolve();if(!e.disableOAuth2StateCheck&&!t.validateNonce(l)){const d=new k("invalid_nonce_in_state",null);return t.eventsSubject.next(d),Promise.reject(d)}}return t.storeSessionState(c),n&&(yield t.getTokenFromCode(n,e),t.restoreRequestedRoute()),Promise.resolve()})()}saveRequestedRoute(){this.config.preserveRequestedRoute&&this._storage.setItem("requested_route",window.location.pathname+window.location.search)}restoreRequestedRoute(){const e=this._storage.getItem("requested_route");e&&history.replaceState(null,"",window.location.origin+e)}getCodePartsFromUrl(e){return e&&0!==e.length?("?"===e.charAt(0)&&(e=e.substr(1)),this.urlHelper.parseQueryString(e)):this.urlHelper.getHashFragmentParams()}getTokenFromCode(e,t){let i=new b.HttpParams({encoder:new A}).set("grant_type","authorization_code").set("code",e).set("redirect_uri",t.customRedirectUri||this.redirectUri);if(!this.disablePKCE){let s;s=this.saveNoncesInLocalStorage&&typeof window.localStorage<"u"?localStorage.getItem("PKCE_verifier"):this._storage.getItem("PKCE_verifier"),s?i=i.set("code_verifier",s):console.warn("No PKCE verifier found in oauth storage!")}return this.fetchAndProcessToken(i,t)}fetchAndProcessToken(e,t){t=t||{},this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint,"tokenEndpoint");let i=(new b.HttpHeaders).set("Content-Type","application/x-www-form-urlencoded");if(this.useHttpBasicAuth){const s=btoa(`${this.clientId}:${this.dummyClientSecret}`);i=i.set("Authorization","Basic "+s)}return this.useHttpBasicAuth||(e=e.set("client_id",this.clientId)),!this.useHttpBasicAuth&&this.dummyClientSecret&&(e=e.set("client_secret",this.dummyClientSecret)),new Promise((s,n)=>{if(this.customQueryParams)for(let r of Object.getOwnPropertyNames(this.customQueryParams))e=e.set(r,this.customQueryParams[r]);this.http.post(this.tokenEndpoint,e,{headers:i}).subscribe(r=>{this.debug("refresh tokenResponse",r),this.storeAccessTokenResponse(r.access_token,r.refresh_token,r.expires_in||this.fallbackAccessTokenExpirationTimeInSec,r.scope,this.extractRecognizedCustomParameters(r)),this.oidc&&r.id_token?this.processIdToken(r.id_token,r.access_token,t.disableNonceCheck).then(c=>{this.storeIdToken(c),this.eventsSubject.next(new S("token_received")),this.eventsSubject.next(new S("token_refreshed")),s(r)}).catch(c=>{this.eventsSubject.next(new k("token_validation_error",c)),console.error("Error validating tokens"),console.error(c),n(c)}):(this.eventsSubject.next(new S("token_received")),this.eventsSubject.next(new S("token_refreshed")),s(r))},r=>{console.error("Error getting token",r),this.eventsSubject.next(new k("token_refresh_error",r)),n(r)})})}tryLoginImplicitFlow(e=null){let t;t=(e=e||{}).customHashFragment?this.urlHelper.getHashFragmentParams(e.customHashFragment):this.urlHelper.getHashFragmentParams(),this.debug("parsed url",t);const i=t.state;let[s,n]=this.parseState(i);if(this.state=n,t.error){this.debug("error trying to login"),this.handleLoginError(e,t);const a=new k("token_error",{},t);return this.eventsSubject.next(a),Promise.reject(a)}const r=t.access_token,c=t.id_token,l=t.session_state,f=t.scope;if(!this.requestAccessToken&&!this.oidc)return Promise.reject("Either requestAccessToken or oidc (or both) must be true.");if(this.requestAccessToken&&!r||this.requestAccessToken&&!e.disableOAuth2StateCheck&&!i||this.oidc&&!c)return Promise.resolve(!1);if(this.sessionChecksEnabled&&!l&&this.logger.warn("session checks (Session Status Change Notification) were activated in the configuration but the id_token does not contain a session_state claim"),this.requestAccessToken&&!e.disableNonceCheck&&!this.validateNonce(s)){const d=new k("invalid_nonce_in_state",null);return this.eventsSubject.next(d),Promise.reject(d)}return this.requestAccessToken&&this.storeAccessTokenResponse(r,null,t.expires_in||this.fallbackAccessTokenExpirationTimeInSec,f),this.oidc?this.processIdToken(c,r,e.disableNonceCheck).then(a=>e.validationHandler?e.validationHandler({accessToken:r,idClaims:a.idTokenClaims,idToken:a.idToken,state:i}).then(d=>a):a).then(a=>(this.storeIdToken(a),this.storeSessionState(l),this.clearHashAfterLogin&&!e.preventClearHashAfterLogin&&this.clearLocationHash(),this.eventsSubject.next(new S("token_received")),this.callOnTokenReceivedIfExists(e),this.inImplicitFlow=!1,!0)).catch(a=>(this.eventsSubject.next(new k("token_validation_error",a)),this.logger.error("Error validating tokens"),this.logger.error(a),Promise.reject(a))):(this.eventsSubject.next(new S("token_received")),this.clearHashAfterLogin&&!e.preventClearHashAfterLogin&&this.clearLocationHash(),this.callOnTokenReceivedIfExists(e),Promise.resolve(!0))}parseState(e){let t=e,i="";if(e){const s=e.indexOf(this.config.nonceStateSeparator);s>-1&&(t=e.substr(0,s),i=e.substr(s+this.config.nonceStateSeparator.length))}return[t,i]}validateNonce(e){let t;return t=this.saveNoncesInLocalStorage&&typeof window.localStorage<"u"?localStorage.getItem("nonce"):this._storage.getItem("nonce"),t===e||(console.error("Validating access_token failed, wrong state/nonce.",t,e),!1)}storeIdToken(e){this._storage.setItem("id_token",e.idToken),this._storage.setItem("id_token_claims_obj",e.idTokenClaimsJson),this._storage.setItem("id_token_expires_at",""+e.idTokenExpiresAt),this._storage.setItem("id_token_stored_at",""+this.dateTimeService.now())}storeSessionState(e){this._storage.setItem("session_state",e)}getSessionState(){return this._storage.getItem("session_state")}handleLoginError(e,t){e.onLoginError&&e.onLoginError(t),this.clearHashAfterLogin&&!e.preventClearHashAfterLogin&&this.clearLocationHash()}getClockSkewInMsec(e=6e5){return this.clockSkewInSec||0===this.clockSkewInSec?1e3*this.clockSkewInSec:e}processIdToken(e,t,i=!1){const s=e.split("."),r=M(this.padBase64(s[0])),c=JSON.parse(r),f=M(this.padBase64(s[1])),a=JSON.parse(f);let d;if(d=this.saveNoncesInLocalStorage&&typeof window.localStorage<"u"?localStorage.getItem("nonce"):this._storage.getItem("nonce"),Array.isArray(a.aud)){if(a.aud.every(m=>m!==this.clientId)){const m="Wrong audience: "+a.aud.join(",");return this.logger.warn(m),Promise.reject(m)}}else if(a.aud!==this.clientId){const m="Wrong audience: "+a.aud;return this.logger.warn(m),Promise.reject(m)}if(!a.sub){const m="No sub claim in id_token";return this.logger.warn(m),Promise.reject(m)}if(this.sessionChecksEnabled&&this.silentRefreshSubject&&this.silentRefreshSubject!==a.sub){const m=`After refreshing, we got an id_token for another user (sub). Expected sub: ${this.silentRefreshSubject}, received sub: ${a.sub}`;return this.logger.warn(m),Promise.reject(m)}if(!a.iat){const m="No iat claim in id_token";return this.logger.warn(m),Promise.reject(m)}if(!this.skipIssuerCheck&&a.iss!==this.issuer){const m="Wrong issuer: "+a.iss;return this.logger.warn(m),Promise.reject(m)}if(!i&&a.nonce!==d){const m="Wrong nonce: "+a.nonce;return this.logger.warn(m),Promise.reject(m)}if(this.hasOwnProperty("responseType")&&("code"===this.responseType||"id_token"===this.responseType)&&(this.disableAtHashCheck=!0),!this.disableAtHashCheck&&this.requestAccessToken&&!a.at_hash){const m="An at_hash is needed!";return this.logger.warn(m),Promise.reject(m)}const u=this.dateTimeService.now(),g=1e3*a.iat,v=1e3*a.exp,I=this.getClockSkewInMsec();if(g-I>=u||v+I-this.decreaseExpirationBySec<=u){const m="Token has expired";return console.error(m),console.error({now:u,issuedAtMSec:g,expiresAtMSec:v}),Promise.reject(m)}const T={accessToken:t,idToken:e,jwks:this.jwks,idTokenClaims:a,idTokenHeader:c,loadKeys:()=>this.loadJwks()};return this.disableAtHashCheck?this.checkSignature(T).then(m=>({idToken:e,idTokenClaims:a,idTokenClaimsJson:f,idTokenHeader:c,idTokenHeaderJson:r,idTokenExpiresAt:v})):this.checkAtHash(T).then(m=>{if(!this.disableAtHashCheck&&this.requestAccessToken&&!m){const P="Wrong at_hash";return this.logger.warn(P),Promise.reject(P)}return this.checkSignature(T).then(P=>{const q={idToken:e,idTokenClaims:a,idTokenClaimsJson:f,idTokenHeader:c,idTokenHeaderJson:r,idTokenExpiresAt:v};return this.disableAtHashCheck?q:this.checkAtHash(T).then(de=>{if(this.requestAccessToken&&!de){const K="Wrong at_hash";return this.logger.warn(K),Promise.reject(K)}return q})})})}getIdentityClaims(){const e=this._storage.getItem("id_token_claims_obj");return e?JSON.parse(e):null}getGrantedScopes(){const e=this._storage.getItem("granted_scopes");return e?JSON.parse(e):null}getIdToken(){return this._storage?this._storage.getItem("id_token"):null}padBase64(e){for(;e.length%4!=0;)e+="=";return e}getAccessToken(){return this._storage?this._storage.getItem("access_token"):null}getRefreshToken(){return this._storage?this._storage.getItem("refresh_token"):null}getAccessTokenExpiration(){return this._storage.getItem("expires_at")?parseInt(this._storage.getItem("expires_at"),10):null}getAccessTokenStoredAt(){return parseInt(this._storage.getItem("access_token_stored_at"),10)}getIdTokenStoredAt(){return parseInt(this._storage.getItem("id_token_stored_at"),10)}getIdTokenExpiration(){return this._storage.getItem("id_token_expires_at")?parseInt(this._storage.getItem("id_token_expires_at"),10):null}hasValidAccessToken(){if(this.getAccessToken()){const e=this._storage.getItem("expires_at"),t=this.dateTimeService.new();return!(e&&parseInt(e,10)-this.decreaseExpirationBySec<t.getTime()-this.getClockSkewInMsec())}return!1}hasValidIdToken(){if(this.getIdToken()){const e=this._storage.getItem("id_token_expires_at"),t=this.dateTimeService.new();return!(e&&parseInt(e,10)-this.decreaseExpirationBySec<t.getTime()-this.getClockSkewInMsec())}return!1}getCustomTokenResponseProperty(e){return this._storage&&this.config.customTokenParameters&&this.config.customTokenParameters.indexOf(e)>=0&&null!==this._storage.getItem(e)?JSON.parse(this._storage.getItem(e)):null}authorizationHeader(){return"Bearer "+this.getAccessToken()}logOut(e={},t=""){let i=!1;"boolean"==typeof e&&(i=e,e={});const s=this.getIdToken();if(this._storage.removeItem("access_token"),this._storage.removeItem("id_token"),this._storage.removeItem("refresh_token"),this.saveNoncesInLocalStorage?(localStorage.removeItem("nonce"),localStorage.removeItem("PKCE_verifier")):(this._storage.removeItem("nonce"),this._storage.removeItem("PKCE_verifier")),this._storage.removeItem("expires_at"),this._storage.removeItem("id_token_claims_obj"),this._storage.removeItem("id_token_expires_at"),this._storage.removeItem("id_token_stored_at"),this._storage.removeItem("access_token_stored_at"),this._storage.removeItem("granted_scopes"),this._storage.removeItem("session_state"),this.config.customTokenParameters&&this.config.customTokenParameters.forEach(r=>this._storage.removeItem(r)),this.silentRefreshSubject=null,this.eventsSubject.next(new y("logout")),!this.logoutUrl||i)return;let n;if(!this.validateUrlForHttps(this.logoutUrl))throw new Error("logoutUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).");if(this.logoutUrl.indexOf("{{")>-1)n=this.logoutUrl.replace(/\{\{id_token\}\}/,encodeURIComponent(s)).replace(/\{\{client_id\}\}/,encodeURIComponent(this.clientId));else{let r=new b.HttpParams({encoder:new A});s&&(r=r.set("id_token_hint",s));const c=this.postLogoutRedirectUri||this.redirectUriAsPostLogoutRedirectUriFallback&&this.redirectUri||"";c&&(r=r.set("post_logout_redirect_uri",c),t&&(r=r.set("state",t)));for(let l in e)r=r.set(l,e[l]);n=this.logoutUrl+(this.logoutUrl.indexOf("?")>-1?"&":"?")+r.toString()}this.config.openUri(n)}createAndSaveNonce(){const e=this;return this.createNonce().then(function(t){return e.saveNoncesInLocalStorage&&typeof window.localStorage<"u"?localStorage.setItem("nonce",t):e._storage.setItem("nonce",t),t})}ngOnDestroy(){this.clearAccessTokenTimer(),this.clearIdTokenTimer(),this.removeSilentRefreshEventListener();const e=this.document.getElementById(this.silentRefreshIFrameName);e&&e.remove(),this.stopSessionCheckTimer(),this.removeSessionCheckEventListener();const t=this.document.getElementById(this.sessionCheckIFrameName);t&&t.remove()}createNonce(){return new Promise(e=>{if(this.rngUrl)throw new Error("createNonce with rng-web-api has not been implemented so far");const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";let i=45,s="";const n=typeof self>"u"?null:self.crypto||self.msCrypto;if(n){let r=new Uint8Array(i);n.getRandomValues(r),r.map||(r.map=Array.prototype.map),r=r.map(c=>t.charCodeAt(c%66)),s=String.fromCharCode.apply(null,r)}else for(;0<i--;)s+=t[66*Math.random()|0];e(L(s))})}checkAtHash(e){var t=this;return(0,x.Z)(function*(){return t.tokenValidationHandler?t.tokenValidationHandler.validateAtHash(e):(t.logger.warn("No tokenValidationHandler configured. Cannot check at_hash."),!0)})()}checkSignature(e){return this.tokenValidationHandler?this.tokenValidationHandler.validateSignature(e):(this.logger.warn("No tokenValidationHandler configured. Cannot check signature."),Promise.resolve(null))}initLoginFlow(e="",t={}){return"code"===this.responseType?this.initCodeFlow(e,t):this.initImplicitFlow(e,t)}initCodeFlow(e="",t={}){""!==this.loginUrl?this.initCodeFlowInternal(e,t):this.events.pipe((0,p.filter)(i=>"discovery_document_loaded"===i.type)).subscribe(i=>this.initCodeFlowInternal(e,t))}initCodeFlowInternal(e="",t={}){if(!this.validateUrlForHttps(this.loginUrl))throw new Error("loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).");let i={},s=null;"string"==typeof t?s=t:"object"==typeof t&&(i=t),this.createLoginUrl(e,s,null,!1,i).then(this.config.openUri).catch(n=>{console.error("Error in initAuthorizationCodeFlow"),console.error(n)})}createChallangeVerifierPairForPKCE(){var e=this;return(0,x.Z)(function*(){if(!e.crypto)throw new Error("PKCE support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?");const t=yield e.createNonce();return[L(yield e.crypto.calcHash(t,"sha-256")),t]})()}extractRecognizedCustomParameters(e){let t=new Map;return this.config.customTokenParameters&&this.config.customTokenParameters.forEach(i=>{e[i]&&t.set(i,JSON.stringify(e[i]))}),t}revokeTokenAndLogout(e={},t=!1){let i=this.revocationEndpoint,s=this.getAccessToken(),n=this.getRefreshToken();if(!s)return Promise.resolve();let r=new b.HttpParams({encoder:new A}),c=(new b.HttpHeaders).set("Content-Type","application/x-www-form-urlencoded");if(this.useHttpBasicAuth){const l=btoa(`${this.clientId}:${this.dummyClientSecret}`);c=c.set("Authorization","Basic "+l)}if(this.useHttpBasicAuth||(r=r.set("client_id",this.clientId)),!this.useHttpBasicAuth&&this.dummyClientSecret&&(r=r.set("client_secret",this.dummyClientSecret)),this.customQueryParams)for(const l of Object.getOwnPropertyNames(this.customQueryParams))r=r.set(l,this.customQueryParams[l]);return new Promise((l,f)=>{let a,d;if(s){let u=r.set("token",s).set("token_type_hint","access_token");a=this.http.post(i,u,{headers:c})}else a=(0,_.of)(null);if(n){let u=r.set("token",n).set("token_type_hint","refresh_token");d=this.http.post(i,u,{headers:c})}else d=(0,_.of)(null);t&&(a=a.pipe((0,p.catchError)(u=>0===u.status?(0,_.of)(null):(0,_.throwError)(u))),d=d.pipe((0,p.catchError)(u=>0===u.status?(0,_.of)(null):(0,_.throwError)(u)))),(0,_.combineLatest)([a,d]).subscribe(u=>{this.logOut(e),l(u),this.logger.info("Token successfully revoked")},u=>{this.logger.error("Error revoking token",u),this.eventsSubject.next(new k("token_revoke_error",u)),f(u)})})}clearLocationHash(){""!=location.hash&&(location.hash="")}}return h.\u0275fac=function(e){return new(e||h)(w.\u0275\u0275inject(w.NgZone),w.\u0275\u0275inject(b.HttpClient),w.\u0275\u0275inject(D,8),w.\u0275\u0275inject(N,8),w.\u0275\u0275inject(H,8),w.\u0275\u0275inject(B),w.\u0275\u0275inject(O),w.\u0275\u0275inject(J,8),w.\u0275\u0275inject(W.DOCUMENT),w.\u0275\u0275inject(F))},h.\u0275prov=w.\u0275\u0275defineInjectable({token:h,factory:h.\u0275fac}),h})();new w.InjectionToken("AUTH_CONFIG")}}]);